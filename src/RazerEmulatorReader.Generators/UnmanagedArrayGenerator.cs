using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace RazerEmulatorReader.Generators;

/// <summary>
///     Source generator used to expand structs into unmanaged-compatible ones.
///     This means instead of using an array internally, or a fixed buffer,
///     we stack X times the struct manually with fields, then add an operator to access them by index.
/// </summary>
[Generator]
public class UnmanagedArrayGenerator : ISourceGenerator
{
    //Example:
    //[UnmanagedArray(typeof(ChildTestStruct), 2)]
    //public readonly partial struct TestStruct
    //{ }

    //Generates:
    //public readonly partial struct TestStruct
    //{
    //    public int Count => 2;
    //    public ChildTestStruct Child0;
    //    public ChildTestStruct Child1;
    //
    //    public ChildTestStruct this[int index] => index switch
    //    {
    //        0 => Child0,
    //        1 => Child1,
    //        _ => throw new IndexOutOfRangeException()
    //    };
    //}

    public void Initialize(GeneratorInitializationContext context)
    {
        //empty
    }

    public void Execute(GeneratorExecutionContext context)
    {
        List<StructInfo> structInfos = new();

        var structs = context.Compilation.SyntaxTrees
            .SelectMany(st => st.GetRoot()
                .DescendantNodes()
                .OfType<StructDeclarationSyntax>()
                .Where(r => r.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Any(a => a.Name.GetText().ToString() == "UnmanagedArray")));

        foreach (var s in structs)
        {
            var tree = s.SyntaxTree;
            var model = context.Compilation.GetSemanticModel(tree);

            var structAttribute = s.AttributeLists
                .SelectMany(al => al.Attributes)
                .First(a => a.Name.GetText().ToString() == "UnmanagedArray");

            var structParameters = structAttribute.ArgumentList!.Arguments;

            var childType = model.GetTypeInfo((structParameters[0].Expression as TypeOfExpressionSyntax)!.Type);
            var childCount = int.Parse(structParameters[1].Expression.ToString());

            var parentType = model.GetDeclaredSymbol(s);

            structInfos.Add(new StructInfo
            {
                Namespace = parentType!.ContainingNamespace.ToString(),
                ParentStruct = parentType!.ToString().Split('.').Last(),
                ChildStruct = childType!.Type!.ToString().Split('.').Last(),
                Count = childCount
            });
        }

        foreach (var structInfo in structInfos)
        {
            context.AddSource($"{structInfo.ParentStruct}.g.cs", GenerateSource(structInfo));
        }
    }

    private string GenerateSource(StructInfo structInfo)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine();
        sb.AppendLine($"namespace {structInfo.Namespace};");
        sb.AppendLine();
        sb.AppendLine("[StructLayout(LayoutKind.Sequential, Pack = 1)]");
        sb.AppendLine($"public readonly partial struct {structInfo.ParentStruct}");
        sb.AppendLine("{");
        sb.AppendLine("    public int Count => " + structInfo.Count + ";");

        var digits = structInfo.Count.ToString(CultureInfo.InvariantCulture).Length;
        var format = "D" + digits;
        for (int i = 0; i < structInfo.Count; i++)
        {
            sb.AppendLine($"    private readonly {structInfo.ChildStruct} Child{i.ToString(format)};");
        }

        sb.AppendLine();
        sb.AppendLine($"    public {structInfo.ChildStruct} this[int index] => index switch");
        sb.AppendLine("    {");
        for (int i = 0; i < structInfo.Count; i++)
        {
            sb.AppendLine($"        {i} => Child{i.ToString(format)},");
        }
        sb.AppendLine($"        _ => throw new IndexOutOfRangeException()");
        sb.AppendLine("    };");
        sb.AppendLine("}");

        return sb.ToString();
    }

    static string GetNamespace(BaseTypeDeclarationSyntax syntax)
    {
        // If we don't have a namespace at all we'll return an empty string
        // This accounts for the "default namespace" case
        string nameSpace = string.Empty;

        // Get the containing syntax node for the type declaration
        // (could be a nested type, for example)
        SyntaxNode? potentialNamespaceParent = syntax.Parent;

        // Keep moving "out" of nested classes etc until we get to a namespace
        // or until we run out of parents
        while (potentialNamespaceParent != null &&
               potentialNamespaceParent is not NamespaceDeclarationSyntax
               && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        // Build up the final namespace by looping until we no longer have a namespace declaration
        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            // We have a namespace. Use that as the type
            nameSpace = namespaceParent.Name.ToString();

            // Keep moving "out" of the namespace declarations until we 
            // run out of nested namespace declarations
            while (true)
            {
                if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
                {
                    break;
                }

                // Add the outer namespace as a prefix to the final namespace
                nameSpace = $"{namespaceParent.Name}.{nameSpace}";
                namespaceParent = parent;
            }
        }

        // return the final namespace
        return nameSpace;
    }
}

public class StructInfo
{
    public string Namespace { get; set; }
    public string ParentStruct { get; set; }
    public string ChildStruct { get; set; }
    public int Count { get; set; }
}